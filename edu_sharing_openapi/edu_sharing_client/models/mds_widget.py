# coding: utf-8

"""
    edu-sharing Repository REST API

    The public restful API of the edu-sharing repository.

    The version of the OpenAPI document: 1.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from edu_sharing_client.models.mds_subwidget import MdsSubwidget
from edu_sharing_client.models.mds_value import MdsValue
from edu_sharing_client.models.mds_widget_condition import MdsWidgetCondition
from typing import Optional, Set
from typing_extensions import Self

class MdsWidget(BaseModel):
    """
    MdsWidget
    """ # noqa: E501
    ids: Optional[Dict[str, StrictStr]] = None
    link: Optional[StrictStr] = None
    configuration: Optional[StrictStr] = None
    format: Optional[StrictStr] = None
    allow_valuespace_suggestions: Optional[StrictBool] = Field(default=None, alias="allowValuespaceSuggestions")
    count_defaultvalue_as_filter: Optional[StrictBool] = Field(default=None, description="When true, a set defaultvalue will still trigger the search to show an active filter. When false (default), the defaultvalue will be shown as if no filter is active", alias="countDefaultvalueAsFilter")
    condition: Optional[MdsWidgetCondition] = None
    maxlength: Optional[StrictInt] = None
    interaction_type: Optional[StrictStr] = Field(default=None, alias="interactionType")
    filter_mode: Optional[StrictStr] = Field(default=None, alias="filterMode")
    expandable: Optional[StrictStr] = None
    subwidgets: Optional[List[MdsSubwidget]] = None
    required: Optional[StrictStr] = None
    id: Optional[StrictStr] = None
    caption: Optional[StrictStr] = None
    bottom_caption: Optional[StrictStr] = Field(default=None, alias="bottomCaption")
    icon: Optional[StrictStr] = None
    type: Optional[StrictStr] = None
    template: Optional[StrictStr] = None
    has_values: Optional[StrictBool] = Field(default=None, alias="hasValues")
    values: Optional[List[MdsValue]] = None
    placeholder: Optional[StrictStr] = None
    unit: Optional[StrictStr] = None
    min: Optional[StrictInt] = None
    max: Optional[StrictInt] = None
    default_min: Optional[StrictInt] = Field(default=None, alias="defaultMin")
    default_max: Optional[StrictInt] = Field(default=None, alias="defaultMax")
    step: Optional[StrictInt] = None
    is_required: Optional[StrictStr] = Field(default=None, alias="isRequired")
    allowempty: Optional[StrictBool] = None
    defaultvalue: Optional[StrictStr] = None
    is_extended: Optional[StrictBool] = Field(default=None, alias="isExtended")
    is_searchable: Optional[StrictBool] = Field(default=None, alias="isSearchable")
    hide_if_empty: Optional[StrictBool] = Field(default=None, alias="hideIfEmpty")
    __properties: ClassVar[List[str]] = ["ids", "link", "configuration", "format", "allowValuespaceSuggestions", "countDefaultvalueAsFilter", "condition", "maxlength", "interactionType", "filterMode", "expandable", "subwidgets", "required", "id", "caption", "bottomCaption", "icon", "type", "template", "hasValues", "values", "placeholder", "unit", "min", "max", "defaultMin", "defaultMax", "step", "isRequired", "allowempty", "defaultvalue", "isExtended", "isSearchable", "hideIfEmpty"]

    @field_validator('interaction_type')
    def interaction_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Input', 'None']):
            raise ValueError("must be one of enum values ('Input', 'None')")
        return value

    @field_validator('filter_mode')
    def filter_mode_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['disabled', 'auto', 'always']):
            raise ValueError("must be one of enum values ('disabled', 'auto', 'always')")
        return value

    @field_validator('expandable')
    def expandable_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['disabled', 'expanded', 'collapsed']):
            raise ValueError("must be one of enum values ('disabled', 'expanded', 'collapsed')")
        return value

    @field_validator('required')
    def required_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['mandatory', 'mandatoryForPublish', 'recommended', 'optional', 'ignore']):
            raise ValueError("must be one of enum values ('mandatory', 'mandatoryForPublish', 'recommended', 'optional', 'ignore')")
        return value

    @field_validator('is_required')
    def is_required_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['mandatory', 'mandatoryForPublish', 'recommended', 'optional', 'ignore']):
            raise ValueError("must be one of enum values ('mandatory', 'mandatoryForPublish', 'recommended', 'optional', 'ignore')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of MdsWidget from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of condition
        if self.condition:
            _dict['condition'] = self.condition.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in subwidgets (list)
        _items = []
        if self.subwidgets:
            for _item_subwidgets in self.subwidgets:
                if _item_subwidgets:
                    _items.append(_item_subwidgets.to_dict())
            _dict['subwidgets'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in values (list)
        _items = []
        if self.values:
            for _item_values in self.values:
                if _item_values:
                    _items.append(_item_values.to_dict())
            _dict['values'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of MdsWidget from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "ids": obj.get("ids"),
            "link": obj.get("link"),
            "configuration": obj.get("configuration"),
            "format": obj.get("format"),
            "allowValuespaceSuggestions": obj.get("allowValuespaceSuggestions"),
            "countDefaultvalueAsFilter": obj.get("countDefaultvalueAsFilter"),
            "condition": MdsWidgetCondition.from_dict(obj["condition"]) if obj.get("condition") is not None else None,
            "maxlength": obj.get("maxlength"),
            "interactionType": obj.get("interactionType"),
            "filterMode": obj.get("filterMode"),
            "expandable": obj.get("expandable"),
            "subwidgets": [MdsSubwidget.from_dict(_item) for _item in obj["subwidgets"]] if obj.get("subwidgets") is not None else None,
            "required": obj.get("required"),
            "id": obj.get("id"),
            "caption": obj.get("caption"),
            "bottomCaption": obj.get("bottomCaption"),
            "icon": obj.get("icon"),
            "type": obj.get("type"),
            "template": obj.get("template"),
            "hasValues": obj.get("hasValues"),
            "values": [MdsValue.from_dict(_item) for _item in obj["values"]] if obj.get("values") is not None else None,
            "placeholder": obj.get("placeholder"),
            "unit": obj.get("unit"),
            "min": obj.get("min"),
            "max": obj.get("max"),
            "defaultMin": obj.get("defaultMin"),
            "defaultMax": obj.get("defaultMax"),
            "step": obj.get("step"),
            "isRequired": obj.get("isRequired"),
            "allowempty": obj.get("allowempty"),
            "defaultvalue": obj.get("defaultvalue"),
            "isExtended": obj.get("isExtended"),
            "isSearchable": obj.get("isSearchable"),
            "hideIfEmpty": obj.get("hideIfEmpty")
        })
        return _obj


